## My code playground for cryptographic programs
# Learning Cryptography: One Byte at a Time
## — A Practical Guide for Curious Minds —
* Note this is for education, not for professional use. My journey may be beneficial for others making the same trek, but it does not **at all** contain the best, fastest, most efficient programs in the world. The code is heavily-commented and all of my own confusions are honestly revealed as I made this journey myself.

# How I Got Into Cryptography
I came from a family that was heavily oriented towards mathematics and engineering. About 5 years ago, I picked up the book *'In Code' by Sarah Flannery* and it got me thinking. But, fate quickly threw me instead into the world of compilers. I was so interested in them and how they worked that I made the same toy language - Gizmo - in about 10+ different languages on various platforms. I even learned HTML and JavaScript just so I could use my knowledge of "lexing" to make a syntax highlighter in my own custom IDE. Believe me... I came from humble beginnings in the world of compilers. I used to just love reading other peoples' code to implement them. I adored the structured approach of having a separate step for lexical analysis, parsing, and then code generation for the target language. But cryptography kept nagging at me. I saw it as a more mature, difficult topic to tackle, so I just kept working on my compilers.

However, the interest in compilers dropped off and schoolwork inevitably took precedence over the really interesting and fun things. For years, GitHub lay dormant... collecting updates and changes - and more and more multi-factor authentication steps. Recently, I got sick and was laying on the couch for a few days. The same book - *'In Code' by Sarah Flannery* - showed up on the fireplace. I dove into it with all the gusto of a sick person with nothing else creative and interesting to apply myself to. This sparked something. It reignited the part of me that loved to analyze the translation systems from before. Before long, I had implemented several different simple ciphers in Rust. And then I felt I had to do it in Python because I wanted the code to be easily digestible. I had to learn to comment my thoughts again... heh, *oops*. I saw that in order to really reach the higher levels of cryptography, there needed to be higher level math.

So, to escape the terrible experience of Calculus as taught at school (which I was going through at the time)... I had to jump headfirst into the strange world where I kept forgetting the difference between **Euler** and **Euclid**. Their contributions to the number theory field of math are quite staggering. The modulus operator moved to the forefront of my daily thought processes and it gave me a headache. But it also left a lingering feeling of satisfaction that I had a powerful tool in my hands. **Prime numbers** - yeah, remember those annoying things from early primary school that seemed to have no purpose in anything? - well... they make up every single other composite number. They are constantly associated with the "atoms of the mathematical world" and they have proved to be notoriously difficult for even modern computers to untangle. I fell in love with it in just a few weeks and everybody I knew thought I was a little bit weird. That might have been because I was muttering to myself about the Sieve of Eratosthenes (the WHAT?) or the Extended Euclidean Algorithm.

At Christmas, my uncle (a math teacher himself) gave me another book - *'The Music of the Primes' by Marcus du Sautoy*. This one would make me fall again in love with the brilliant and beautiful mathematics in cryptography. I had a whole new set of topics to mess around with: the Riemann Zeta function, inputting complex numbers to everything, Fourier Transforms, theories about the distribution of prime numbers. Yes, it was a lot of work and thinking and head-hurting. Yes, it was a lot of *fun* as well. And it doesn't have to be intimidating at all. Little pictures are fun. Physical models of Caesar's Ciphers are fun. And sometimes counting with rocks can be fun as well... maybe... Anyway! Join me as I try to relate my journey to all of you! And to all you smarter ones who are looking at how stupidly I've done these things can help me out as well. Because I'm here to learn **with** all of you and **from** all of you. Please, let's have some fun!

Organized into readable chapters, this online book (journal? playground?) aims to get you up to speed with the current state of cryptography (well, my pretty sad knowledge of the state of cryptography). Each chapter has several examples with images and well-documented Python code.
## Overview / Table of Contents
| Chapter | Description |
|-|-|
| **Chapter 1: Why is Cryptography Necessary?** | Explains the *why* behind centuries-old ciphers and modern-day encryption |
| **Chapter 2: Simple Ciphers (Caesar's, Vigenere's, Playfair, Hill)** | Explores a variety of simple ciphers, as well as their implementations, limitations, and weaknesses |
| **Chapter 3: One-Time Pads** | A guide to a simple and secure (but inconvenient) encryption |
| **Chapter 4: Public Key Cryptography** | Describes a system in which anybody can encrypt, but only one party can decrypt |
| **Chapter 5: Modular Arithmetic, Prime Numbers, and RSA** | Reveals the mathematics that holds up one of modern cryptography's strongest systems: RSA  |
